// kind=shader
uniform float u_time;
uniform float2 u_resolution;

// Створюємо константу Пі для математики кутів
const float PI = 3.14159265;

half4 main(float2 fragCoord) {
    // 1. Нормалізація (центр у 0.0)
    // Використовуємо min(x, y), щоб гарантувати ідеально кругові пропорції 
    // незалежно від того, горизонтальний у нас екран чи вертикальний.
    float2 uv = (fragCoord - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);

    // ==========================================
    // 2. ДЕКАРТОВІ -> ПОЛЯРНІ КООРДИНАТИ
    // ==========================================
    
    // length(uv) - це вбудована функція, яка використовує теорему Піфагора 
    // sqrt(x*x + y*y) і повертає відстань пікселя від центру.
    float dist = length(uv);

    // atan(y, x) повертає кут пікселя відносно центру в радіанах.
    // Діапазон: від -PI до +PI (від -3.14 до +3.14)
    float angle = atan(uv.y, uv.x);

    // ==========================================
    // 3. ФОРМУЄМО ПРОМІНЬ
    // ==========================================
    
    // Переводимо кут з діапазону [-PI .. +PI] у зручний діапазон [0.0 .. 1.0]
    float normalizedAngle = (angle / (2.0 * PI)) + 0.5;

    // Віднімаємо час, щоб кут постійно зміщувався (обертався).
    // u_time * 0.5 визначає швидкість обертання радара.
    float rotatedAngle = normalizedAngle - u_time * 0.5;

    // Функція fract(x) залишає лише дробову частину числа (відкидає цілу).
    // Наприклад: fract(1.2) = 0.2; fract(-0.7) = 0.3.
    // Це створює "пилоподібний" сигнал: плавно зростає до 1.0 і миттєво падає в 0.0.
    float sweep = fract(rotatedAngle);

    // ==========================================
    // 4. МАЛЮЄМО ФІГУРУ ТА КОЛІР
    // ==========================================

    // Робимо маску для круглого екрана радара (радіус 0.4)
    // 1.0 - step(0.4, dist) означає: все що ближче за 0.4 буде 1.0, далі — 0.0.
    float circleMask = 1.0 - step(0.4, dist); 

    // Формуємо колір променя. 
    // Де sweep наближається до 1.0 - там яскраво-зелений.
    // Де sweep падає в 0.0 - там чорний.
    half3 radarColor = half3(0.0, sweep, 0.0);

    // Множимо на маску, щоб обрізати світло за межами круга
    return half4(radarColor * circleMask, 1.0);
}