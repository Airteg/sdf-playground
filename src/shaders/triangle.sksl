// kind=shader
uniform float2 u_resolution;

float sdTriangle(float2 uv, float2 p0, float2 p1, float2 p2) {
    // ========================================================
    // 1. ПІДГОТОВКА ВЕКТОРІВ
    // ========================================================
    // e - вектори самих ребер (від точки до точки)
    float2 e0 = p1 - p0;
    float2 e1 = p2 - p1;
    float2 e2 = p0 - p2;

    // w - вектори від точок трикутника до нашого пікселя
    float2 w0 = uv - p0;
    float2 w1 = uv - p1;
    float2 w2 = uv - p2;

    // ========================================================
    // 2. ШУКАЄМО ПРОЕКЦІЇ (Мінімальну фізичну відстань)
    // ========================================================
    float2 b0 = w0 - e0 * clamp(dot(w0, e0) / dot(e0, e0), 0.0, 1.0);
    float2 b1 = w1 - e1 * clamp(dot(w1, e1) / dot(e1, e1), 0.0, 1.0);
    float2 b2 = w2 - e2 * clamp(dot(w2, e2) / dot(e2, e2), 0.0, 1.0);

    // Рахуємо квадрати відстаней для всіх трьох ребер і беремо найменший
    float d = min(min(dot(b0, b0), dot(b1, b1)), dot(b2, b2));

    // ========================================================
    // 3. RAY CASTING (Логіка Знаку)
    // ========================================================
    float s = 1.0;

    // Перевіряємо ребро 0 (p0 -> p1)
    bool condY1_0 = uv.y >= p0.y;
    bool condY2_0 = uv.y < p1.y;
    bool condX_0  = e0.x * w0.y > e0.y * w0.x;
    if ((condY1_0 && condY2_0 && condX_0) || (!condY1_0 && !condY2_0 && !condX_0)) s *= -1.0;

    // Перевіряємо ребро 1 (p1 -> p2)
    bool condY1_1 = uv.y >= p1.y;
    bool condY2_1 = uv.y < p2.y;
    bool condX_1  = e1.x * w1.y > e1.y * w1.x;
    if ((condY1_1 && condY2_1 && condX_1) || (!condY1_1 && !condY2_1 && !condX_1)) s *= -1.0;

    // Перевіряємо ребро 2 (p2 -> p0)
    bool condY1_2 = uv.y >= p2.y;
    bool condY2_2 = uv.y < p0.y;
    bool condX_2  = e2.x * w2.y > e2.y * w2.x;
    if ((condY1_2 && condY2_2 && condX_2) || (!condY1_2 && !condY2_2 && !condX_2)) s *= -1.0;

    // Повертаємо справжню відстань (корінь) зі знаком
    return s * sqrt(d);
}

half4 main(float2 fragCoord) {
    float2 uv = (fragCoord - 0.5 * u_resolution) / u_resolution.x;

    float2 p0 = float2(0.1, -0.2);  
    float2 p1 = float2(0.3, 0.3);   
    float2 p2 = float2(-0.3, 0.3);  

    float dist = sdTriangle(uv, p0, p1, p2);

    float mask = 1.0 - step(0.0, dist);

    return half4(mask, 0.0, 0.0, 1.0);
}