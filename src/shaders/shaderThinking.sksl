// kind=shader
uniform float u_time;
uniform float2 u_resolution;

half4 main(float2 fragCoord) {
    // 1. Афінне перетворення простору (Перехід від дискретних пікселів до математики)
    // Центруємо екран (0,0) та нормалізуємо масштаб відносно ширини
    float2 uv = (fragCoord - 0.5 * u_resolution) / u_resolution.x;

    // 2. Безстанова анімація (Statelessness)
    // Замість збереження стану попереднього кадру, просто беремо синус від часу.
    // Це чиста функція: однаковий u_time завжди дасть однаковий pulse.
    float pulse = sin(u_time * 4.0) * 0.05; 

    // 3. Згортання простору (Уникнення Warp Divergence)
    // Накладаємо 4 чверті екрана одна на одну, щоб не писати умови для кожного кута квадрата
    float2 q = abs(uv);

    // 4. Безперервні функції відстані (SDF)
    // Математична межа квадрата розміром 0.25
    float boxDist = max(q.x, q.y) - 0.25; 
    
    // Математична межа кола, радіус якого дихає завдяки u_time
    float circleDist = length(uv) - (0.2 + pulse);

    // 5. Конструктивна суцільна геометрія (CSG) без if/else
    // Щоб вирізати коло з квадрата, ми беремо негативну відстань кола (-circleDist)
    // і знаходимо перетин через функцію max(). Жодного розгалуження!
    float shapeDist = max(boxDist, -circleDist);

    // 6. Дискретизація та фільтрація (Sampling & Aliasing prevention)
    // Замість жорсткого step(), який дасть "драбинку" з пікселів, 
    // використовуємо smoothstep() як аналоговий фільтр низьких частот.
    // Він створює плавний перехід шириною в 0.005 для ідеального згладжування.
    float mask = smoothstep(0.0, 0.001, shapeDist);

    // 7. Відображення (R² → R⁴)
    // Інвертуємо маску: всередині фігури буде 1.0, зовні 0.0
    float shape = 1.0 - mask;
    
    // Множимо колір на shape: там де 0.0 — буде чорний фон
    return half4(0.0, 0.8 * shape, 1.0 * shape, 1.0);
}